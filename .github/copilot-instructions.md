# eeka - Mouse Gesture to Keyboard Shortcut Mapper

## Architecture Overview

**eeka** is a Linux X11 daemon that transforms mouse button combinations into keyboard shortcuts. It operates at the system level by:

1. **Event Interception**: Uses Linux evdev to grab raw mouse events from `/dev/input/event*` devices
2. **Window Context**: Uses XCB to identify the active window (class/instance) for context-specific bindings
3. **Key Simulation**: Uses XCB XTest extension to inject synthesized keyboard events
4. **Configuration**: Parses a custom DSL config file with global and window-specific rules

## Core Components

- `main.c`: Event loop with `poll()` on XCB and evdev file descriptors, button state management
- `parser.c/h`: Configuration parser for the custom DSL, binding storage and lookup
- `xdg.c/h`: XDG Base Directory compliance for config file discovery and creation
- `eeka.h`: Shared definitions for mouse buttons, key codes, and core data structures
- `build/config.h`: Generated by Makefile with VERSION, PROGRAM_NAME, and DATA_DIR macros

## Key Architectural Patterns

### Button State Machine
Mouse buttons can act as **modifiers** (RButton, LButton, BButton, FButton). The `ButtonState` struct tracks:
- `modifier_pressed`: Which modifier button is currently held
- `combo_used`: Whether the modifier was used in a combination (prevents fallback action)
- `blocked_buttons[]`: Buttons that shouldn't trigger their default action

### Configuration DSL
```
# Global bindings
RButton & ScrollUp = Ctrl+PageDown

# Window-specific rules  
window [class=Code, instance=code] {
    RButton & LButton = Ctrl+B
    blacklist = RButton  # Disable RButton grabbing for this window
}

# Device filtering
device_blacklist = keyd
```

### Window Context Resolution
1. Get pointer coordinates → find window under cursor
2. Walk up window hierarchy to find the actual application window
3. Extract WM_CLASS (instance, class) properties
4. Match against window rules for context-specific bindings

## Development Workflows

### Building
```bash
make clean && make        # Build in build/ directory
make run                  # Clean build + run with test config
```

### Testing
```bash
# Run with verbose logging and custom config
./build/eeka -c .config -V

# Toggle grabbing (useful for development)
eeka --toggle
# or kill -USR1 <pid>
```

### Debugging Mouse Events
- Check `/proc/bus/input/devices` for mouse device detection
- Use `evtest` to verify raw input events
- Monitor syslog for eeka's verbose output

## Critical Implementation Details

### LButton Special Handling
LButton (left mouse) always sends the press event through immediately to preserve normal click/drag functionality, unlike other modifier buttons that block until release.

### Device Blacklisting
Essential for compatibility with other input tools (e.g., keyd). Device names from `/proc/bus/input/devices` can be blacklisted globally.

### Memory Management
- `xdg_get_*` functions return malloc'd strings - caller must free
- Config parsing uses static arrays with MAX_* limits
- Window class info uses fixed-size buffers

### Signal Handling
- SIGTERM/SIGINT: Clean shutdown, remove PID file
- SIGUSR1: Toggle grabbing state (runtime enable/disable)

## Dependencies & Platform Requirements

- **Linux only**: Uses evdev (`/dev/input/event*`) for mouse grabbing
- **X11 only**: Uses XCB for window management and key injection
- **Root/input group**: Requires permissions to access `/dev/input/event*`
- **libxcb-dev**: XCB development headers required for building

## Common Gotchas

1. RButton grabbing breaks right-click drag in games/Blender → use window blacklists
2. Device order in `/dev/input/` can change → device detection is name-based, not path-based  
3. Config syntax is strict → no trailing commas, exact spacing matters
4. Window class matching is case-sensitive and requires exact instance/class names
